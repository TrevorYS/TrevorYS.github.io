{"meta":{"title":"Tracy's Blog","subtitle":null,"description":"welcome to Tracy's Blog","author":"Tracy","url":"http://yoursite.com"},"pages":[{"title":"all-categories","date":"2017-08-30T08:22:41.000Z","updated":"2017-08-30T08:22:41.000Z","comments":false,"path":"all-categories/index.html","permalink":"http://yoursite.com/all-categories/index.html","excerpt":"","text":""},{"title":"all-tags","date":"2017-08-30T08:23:21.000Z","updated":"2017-08-30T08:23:21.000Z","comments":false,"path":"all-tags/index.html","permalink":"http://yoursite.com/all-tags/index.html","excerpt":"","text":""}],"posts":[{"title":"iOS-Skill","slug":"iOS-Skill","date":"2017-08-30T01:52:58.000Z","updated":"2017-08-30T02:20:07.000Z","comments":true,"path":"2017/08/30/iOS-Skill/","link":"","permalink":"http://yoursite.com/2017/08/30/iOS-Skill/","excerpt":"#####iOS开发过程中一些小问题小技巧，代码片段。 利用Safari打开一个链接 12NSURL *url = [NSURL URLWithString:@\"http://baidu.com\"];[[UIApplication sharedApplication] openURL:url];","text":"#####iOS开发过程中一些小问题小技巧，代码片段。 利用Safari打开一个链接 12NSURL *url = [NSURL URLWithString:@\"http://baidu.com\"];[[UIApplication sharedApplication] openURL:url]; 汉字转码 12NSString *oriString = @\"\\u67aa\\u738b\";NSString *escapedString = [oriString stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; 调用电话，短信，邮件 1234[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@\"mailto:apple@mac.com?Subject=hello\"]];sms://调用短信tel://调用电话itms://打开MobileStore.app 获取版本信息 12UIDevice *myDevice = [UIDevice currentDevice];NSString *systemVersion = myDevice.systemVersion; &gt; iPhone 更改键盘右下角按键的 type 1234567SearchBar *mySearchBar = [[UISearchBar alloc]init];mySearchBar.frame = CGRectMake(0, 0, self.view.bounds.size.width, 44);mySearchBar.placeholder = @\"placeholderString\";mySearchBar.delegate = self;[self.view addSubview:mySearchBar];UITextField *searchField = [[mySearchBar subviews] lastObject];searchField.returnKeyType = UIReturnKeyDone; 给图片增加模糊效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//加模糊效果，image是图片，blur是模糊度+ (UIImage *)blurryImage:(UIImage *)image withBlurLevel:(CGFloat)blur &#123; //模糊度, if ((blur &lt; 0.1f) || (blur &gt; 2.0f)) &#123; blur = 0.1f; &#125; //boxSize必须大于0 int boxSize = (int)(blur * 100); boxSize -= (boxSize % 2) + 1; NSLog(@\"boxSize:%i\",boxSize); //图像处理 CGImageRef img = image.CGImage;&gt; //图像缓存,输入缓存，输出缓存 vImage_Buffer inBuffer, outBuffer; vImage_Error error; //像素缓存 void *pixelBuffer;&gt; //数据源提供者，Defines an opaque type that supplies Quartz with data. CGDataProviderRef inProvider = CGImageGetDataProvider(img); // provider’s data. CFDataRef inBitmapData = CGDataProviderCopyData(inProvider);&gt; //宽，高，字节/行，data inBuffer.width = CGImageGetWidth(img); inBuffer.height = CGImageGetHeight(img); inBuffer.rowBytes = CGImageGetBytesPerRow(img); inBuffer.data = (void*)CFDataGetBytePtr(inBitmapData);&gt; //像数缓存，字节行*图片高 pixelBuffer = malloc(CGImageGetBytesPerRow(img) * CGImageGetHeight(img));&gt; outBuffer.data = pixelBuffer; outBuffer.width = CGImageGetWidth(img); outBuffer.height = CGImageGetHeight(img); outBuffer.rowBytes = CGImageGetBytesPerRow(img);&gt; // 第三个中间的缓存区,抗锯齿的效果 void *pixelBuffer2 = malloc(CGImageGetBytesPerRow(img) * CGImageGetHeight(img)); vImage_Buffer outBuffer2; outBuffer2.data = pixelBuffer2; outBuffer2.width = CGImageGetWidth(img); outBuffer2.height = CGImageGetHeight(img); outBuffer2.rowBytes = CGImageGetBytesPerRow(img);&gt; //Convolves a region of interest within an ARGB8888 source image by an implicit M x N kernel that has the effect of a box filter. error = vImageBoxConvolve_ARGB8888(&amp;inBuffer;, &amp;outBuffer2;, NULL, 0, 0, boxSize, boxSize, NULL, kvImageEdgeExtend); error = vImageBoxConvolve_ARGB8888(&amp;outBuffer2;, &amp;inBuffer;, NULL, 0, 0, boxSize, boxSize, NULL, kvImageEdgeExtend); error = vImageBoxConvolve_ARGB8888(&amp;inBuffer;, &amp;outBuffer;, NULL, 0, 0, boxSize, boxSize, NULL, kvImageEdgeExtend);&gt; if (error) &#123; NSLog(@\"error from convolution %ld\", error); &#125;&gt; // NSLog(@\"字节组成部分：%zu\",CGImageGetBitsPerComponent(img)); //颜色空间DeviceRGB CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();&gt; //用图片创建上下文,CGImageGetBitsPerComponent(img),7,8 CGContextRef ctx = CGBitmapContextCreate( outBuffer.data, outBuffer.width, outBuffer.height, 8, outBuffer.rowBytes, colorSpace, CGImageGetBitmapInfo(image.CGImage));&gt; //根据上下文，处理过的图片，重新组件 CGImageRef imageRef = CGBitmapContextCreateImage (ctx); UIImage *returnImage = [UIImage imageWithCGImage:imageRef];&gt; //clean up CGContextRelease(ctx); CGColorSpaceRelease(colorSpace); free(pixelBuffer); free(pixelBuffer2); CFRelease(inBitmapData); CGImageRelease(imageRef);&gt; return returnImage;&#125; 图片压缩 12345678910111213141516用法：UIImage *yourImage= [self imageWithImageSimple:image scaledToSize:CGSizeMake(210.0, 210.0)];//压缩图片- (UIImage*)imageWithImageSimple:(UIImage*)image scaledToSize:(CGSize)newSize&#123;// Create a graphics image contextUIGraphicsBeginImageContext(newSize);// Tell the old image to draw in this newcontext, with the desired// new size[image drawInRect:CGRectMake(0,0,newSize.width,newSize.height)];// Get the new image from the contextUIImage* newImage = UIGraphicsGetImageFromCurrentImageContext();// End the contextUIGraphicsEndImageContext();// Return the new image.return newImage;&#125; 把时间戳转换为时间 1234567891011+ (NSDate *)dateWithTimeIntervalInMilliSecondSince1970:(double)timeIntervalInMilliSecond &#123; NSDate *ret = nil; double timeInterval = timeIntervalInMilliSecond; if(timeIntervalInMilliSecond &gt; 140000000000) &#123; timeInterval = timeIntervalInMilliSecond / 1000; &#125; ret = [NSDate dateWithTimeIntervalSince1970:timeInterval];&gt; return ret;&#125;&gt; 自定义cell中获取不到cell实际大小的办法 12345&gt;-(void)drawRect:(CGRect)rect &#123; // 重写此方法，并在此方法中获取 CGFloat width = self.frame.size.width;&#125;&gt; 长按图标抖动 12345678910111213&gt;-(void)longPress:(UILongPressGestureRecognizer*)longPress&#123; if (longPress.state==UIGestureRecognizerStateBegan) &#123; CAKeyframeAnimation* anim=[CAKeyframeAnimation animation]; anim.keyPath=@\"transform.rotation\"; anim.values=@[@(angelToRandian(-7)),@(angelToRandian(7)),@(angelToRandian(-7))]; anim.repeatCount=MAXFLOAT; anim.duration=0.2; [self.imageView.layer addAnimation:anim forKey:nil]; self.btn.hidden=NO; &#125;&#125;&gt; 两种方法删除NSUserDefaults所有记录 1234567891011121314&gt;//方法一NSString *appDomain = [[NSBundle mainBundle] bundleIdentifier];[[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain];&gt;//方法二- (void)resetDefaults &#123; NSUserDefaults * defs = [NSUserDefaults standardUserDefaults]; NSDictionary * dict = [defs dictionaryRepresentation]; for (id key in dict) &#123; [defs removeObjectForKey:key]; &#125; [defs synchronize];&#125;&gt; 截屏全图 12345678910&gt;- (UIImage *)imageFromView: (UIView *) theView&#123; UIGraphicsBeginImageContext(theView.frame.size); CGContextRef context = UIGraphicsGetCurrentContext(); [theView.layer renderInContext:context]; UIImage *theImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext();&gt; return theImage;&#125;&gt; 去除UIImageView锯齿 12&gt;imageView.layer.shouldRasterize = YES;&gt; 由身份证号码返回性别 12345678910111213141516171819202122232425262728293031&gt;-(NSString *)sexStrFromIdentityCard:(NSString *)numberStr&#123; NSString *result = nil; BOOL isAllNumber = YES;&gt; if([numberStr length]&lt;17) return result;&gt; //**截取第17为性别识别符 NSString *fontNumer = [numberStr substringWithRange:NSMakeRange(16, 1)];&gt; //**检测是否是数字; const char *str = [fontNumer UTF8String]; const char *p = str; while (*p!='\\0') &#123; if(!(*p&gt;='0'&amp;&amp;*p&lt;='9')) isAllNumber = NO; p++; &#125;&gt; if(!isAllNumber) return result;&gt; int sexNumber = [fontNumer integerValue]; if(sexNumber%2==1) result = @\"男\"; else if (sexNumber%2==0) result = @\"女\";&gt; return result; &#125;&gt; 数组随机重新排列 1234567891011121314151617&gt;+ (NSArray *)getRandomWithPosition:(NSInteger)position positionContent:(id)positionContent array:(NSArray *)baseArray &#123; NSMutableArray *resultArray = [NSMutableArray arrayWithCapacity:baseArray.count]; NSMutableArray *tempBaseArray = [NSMutableArray arrayWithArray:baseArray];&gt; while ([tempBaseArray count]) &#123; NSInteger range = [tempBaseArray count]; id string = [tempBaseArray objectAtIndex:arc4random()%range]; [resultArray addObject:string]; [tempBaseArray removeObject:string]; &#125;&gt; NSUInteger index = [resultArray indexOfObject:positionContent]; [resultArray exchangeObjectAtIndex:index withObjectAtIndex:position - 1];&gt; return resultArray;&#125;&gt; 利用陀螺仪实现更真实的微信摇一摇动画 12345678910111213141516171819202122232425&gt;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; application.applicationSupportsShakeToEdit=YES;&#125;&gt;-(void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event &#123; if(motion==UIEventSubtypeMotionShake) &#123; // 真实一点的摇动动画 [self addAnimations]; // 播放声音 AudioServicesPlaySystemSound (soundID); &#125;&#125;&gt;- (void)addAnimations &#123; CABasicAnimation *translation = [CABasicAnimation animationWithKeyPath:@\"transform\"]; translation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; translation.toValue=[NSValue valueWithCATransform3D:CATransform3DMakeRotation(-M_PI_4, 0, 0, 100)]; translation.duration = 0.2; translation.repeatCount = 2; translation.autoreverses = YES;&gt; [shake.layer addAnimation:translation forKey:@\"translation\"];&#125;&gt; 在后台播放音乐 123456789101112131415161718192021&gt;//1. 在Info.plist中，添加\"Required background modes\"键，其值设置是“App plays audio\" //2. 在播放器播放音乐的代码所在处，添加如下两段代码（当然，前提是已经添加了AVFoundation框架）&gt;//添加后台播放代码：AVAudioSession *session = [AVAudioSession sharedInstance]; [session setActive:YES error:nil]; [session setCategory:AVAudioSessionCategoryPlayback error:nil]; &gt; //以及设置app支持接受远程控制事件代码。设置app支持接受远程控制事件，//其实就是在dock中可以显示应用程序图标，同时点击该图片时，打开app。//或者锁屏时，双击home键，屏幕上方出现应用程序播放控制按钮。[[UIApplication sharedApplication] beginReceivingRemoteControlEvents]; &gt;//用下列代码播放音乐，测试后台播放// 创建播放器 AVAudioPlayer *player = [[AVAudioPlayer alloc] initWithContentsOfURL:url error:nil]; [player prepareToPlay]; [player setVolume:1]; player.numberOfLoops = -1; //设置音乐播放次数 -1为一直循环 [player play]; //播放&gt; 利用富文本改变字体颜色 123456789101112&gt;- (NSMutableAttributedString *)changeTextColor:(NSString *)text needChange:(NSString *)value UIColor:(UIColor *)color&#123;&gt; NSMutableAttributedString *attrstring = [[NSMutableAttributedString alloc] initWithString:text];&gt; //1.设置字体颜色 [attrstring addAttribute:NSForegroundColorAttributeName value:color range:[text rangeOfString:value]];&gt; return attrstring;&#125;&gt; 计算两个日期之间的天数 123456789101112131415&gt;- (NSInteger)calcDaysFromBegin:(NSDate *)beginDate end:(NSDate *)endDate&#123; //创建日期格式化对象 NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init]; [dateFormatter setDateFormat:@\"yyyy-MM-dd HH:mm\"];&gt; //取两个日期对象的时间间隔： //这里的NSTimeInterval 并不是对象，是基本型，其实是double类型，是由c定义的:typedef double NSTimeInterval; NSTimeInterval time = [endDate timeIntervalSinceDate:beginDate];&gt; int days = ((int)time) / (3600*24); //int hours=((int)time)%(3600*24)/3600; //NSString *dateContent=[[NSString alloc] initWithFormat:@\"%i天%i小时\",days,hours]; return days;&#125;&gt; 获取上个月或者下个月 +1是下个月 -1是上个月 1234567891011121314&gt;- (NSDate *)getPriousorLaterDateFromDate:(NSDate *)date withMonth:(int)month&#123;&gt; NSDateComponents *comps = [[NSDateComponents alloc] init];&gt; [comps setMonth:month];&gt; NSCalendar *calender = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];&gt; NSDate *mDate = [calender dateByAddingComponents:comps toDate:date options:0];&gt; return mDate;&gt; &#125;&gt; 两个时间比较 1234567891011121314151617181920212223&gt;- (int)compareOneDay:(NSDate *)oneDay withAnotherDay:(NSDate *)anotherDay&#123;&gt; NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init]; [dateFormatter setDateFormat:@\"yyyy/MM/dd\"]; NSString *oneDayStr = [dateFormatter stringFromDate:oneDay]; NSString *anotherDayStr = [dateFormatter stringFromDate:anotherDay]; NSDate *dateA = [dateFormatter dateFromString:oneDayStr]; NSDate *dateB = [dateFormatter dateFromString:anotherDayStr]; NSComparisonResult result = [dateA compare:dateB]; // NSLog(@\"date1 : %@, date2 : %@\", oneDay, anotherDay); if (result == NSOrderedDescending) &#123; //NSLog(@\"Date1 is in the future\"); return 1; &#125; else if (result == NSOrderedAscending)&#123; //NSLog(@\"Date1 is in the past\"); return -1; &#125; //NSLog(@\"Both dates are the same\"); return 0;&gt; &#125;&gt; Date 转 String 123456789101112- (NSString *)stringFromDate:(NSDate *)date&#123;&gt; NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];&gt; [dateFormatter setDateFormat:@\"yyyy/MM/dd\"];&gt; NSString *destDateString = [dateFormatter stringFromDate:date];&gt; return destDateString;&gt; &#125;&gt; String 转Date 123456789101112&gt;- (NSDate *)dateFromString:(NSString *)dateString&#123;&gt; NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];&gt; [dateFormatter setDateFormat: @\"yyyy/MM/dd\"];&gt; NSDate *destDate= [dateFormatter dateFromString:dateString];&gt; return destDate;&gt; &#125;&gt; 浮点转百分比 12345678910111213141516- (NSString *)percentage:(NSString *)value&#123;&gt; float _percent = [value floatValue];&gt; CFLocaleRef currentLocale = CFLocaleCopyCurrent();&gt; CFNumberFormatterRef numberFormatter = CFNumberFormatterCreate(NULL, currentLocale, kCFNumberFormatterPercentStyle);&gt; CFNumberRef number = CFNumberCreate(NULL, kCFNumberFloatType, &amp;_percent);&gt; CFStringRef numberString = CFNumberFormatterCreateStringWithNumber(NULL, numberFormatter, number);&gt; return (__bridge NSString * _Nullable)(numberString);&gt; &#125;&gt; 获取当月第一天跟最后一天 12345678910111213141516171819202122232425262728- (NSString *)getMonthBeginAndEndWith:(NSString *)dateStr&#123;&gt; NSDateFormatter *format=[[NSDateFormatter alloc] init]; [format setDateFormat:@\"yyyy/MM/dd\"]; NSDate *newDate=[format dateFromString:dateStr]; double interval = 0; NSDate *beginDate = nil; NSDate *endDate = nil; NSCalendar *calendar = [NSCalendar currentCalendar];&gt; [calendar setFirstWeekday:2];//设定周一为周首日 BOOL ok = [calendar rangeOfUnit:NSMonthCalendarUnit startDate:&amp;beginDate interval:&amp;interval forDate:newDate]; //分别修改为 NSDayCalendarUnit NSWeekCalendarUnit NSYearCalendarUnit if (ok) &#123; endDate = [beginDate dateByAddingTimeInterval:interval-1]; &#125;else &#123; return @\"\"; &#125; NSDateFormatter *myDateFormatter = [[NSDateFormatter alloc] init]; [myDateFormatter setDateFormat:@\"YYYY/MM/dd\"]; //月初 NSString *beginString = [myDateFormatter stringFromDate:beginDate]; //月末 NSString *endString = [myDateFormatter stringFromDate:endDate]; NSString *s = [NSString stringWithFormat:@\"%@-%@\",beginString,endString]; return s;&#125;&gt; UIColor HEX 123456789101112131415161718192021222324252627282930313233343536373839404142434445&gt;+ (UIColor *)colorWithHexString:(NSString *)color alpha:(CGFloat)alpha&#123; //删除字符串中的空格 NSString *cString = [[color stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]] uppercaseString]; // String should be 6 or 8 characters if ([cString length] &lt; 6) &#123; return [UIColor clearColor]; &#125; // strip 0X if it appears //如果是0x开头的，那么截取字符串，字符串从索引为2的位置开始，一直到末尾 if ([cString hasPrefix:@\"0X\"]) &#123; cString = [cString substringFromIndex:2]; &#125; //如果是#开头的，那么截取字符串，字符串从索引为1的位置开始，一直到末尾 if ([cString hasPrefix:@\"#\"]) &#123; cString = [cString substringFromIndex:1]; &#125; if ([cString length] != 6) &#123; return [UIColor clearColor]; &#125;&gt; // Separate into r, g, b substrings NSRange range; range.location = 0; range.length = 2; //r NSString *rString = [cString substringWithRange:range]; //g range.location = 2; NSString *gString = [cString substringWithRange:range]; //b range.location = 4; NSString *bString = [cString substringWithRange:range];&gt; // Scan values unsigned int r, g, b; [[NSScanner scannerWithString:rString] scanHexInt:&amp;r]; [[NSScanner scannerWithString:gString] scanHexInt:&amp;g]; [[NSScanner scannerWithString:bString] scanHexInt:&amp;b]; return [UIColor colorWithRed:((float)r / 255.0f) green:((float)g / 255.0f) blue:((float)b / 255.0f) alpha:alpha];&#125;&gt; ###Objective-C 内存管理 一个对象可以有一个或多个拥有者 当它一个拥有者都没有的时候，它就会被回收 如果想保留一个对象不被回收，你就必须成为它的拥有者 ###关键字 alloc 为对象分配内存，计数设为1，并返回此对象。 copy 复制一个对象，此对象计数为1，返回此对象。你将成为此克隆对象的拥有者。 retain 对象计数+1，并成为次对象的拥有者。 release 对象计数-1，并丢掉此对象。 autorelease 在未来的 某一个时刻，对象计数-1。并在未来的某个时间放弃此对象。 ###原则 一个代码块内要确保copy，alloc 和 retain 的使用数量与 release 和 autorelease 的数量相等。 在使用以 alloc 或 new 开头或包含 copy 的方法，或 retain 一个对象时，你将会编程它的拥有者。&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 实现 dealloc 方法，这是系统当 retain -&gt; 0 的时候，自动调用的。手动调用会引起 retain count 计数错误（多一次的 release）。 ###tableView性能优化 ####cell的循环利用方式112345678910- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; static NSString *ID = @\"cell\"; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID]; if (cell == nil) &#123; cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleValue1 reuseIdentifier:ID]; &#125; cell.textLabel.text = @\"\"; return cell;&#125; ####cell的循环利用方式2-注册12345678910111213141516171819static NSString *ID = @\"cell\";- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. self.tableview.dataSource = self; self.tableview.delegate = self; [self.tableview registerClass:[UITableViewCell class] forCellReuseIdentifier:@\"cell\"];&#125;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID]; cell.textLabel.text = @\"\"; return cell;&#125; ###自定义cell ####等高cell1234567-(CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath)indexPath&#123; MuziCell *cell = [MuziCell cellWithTableView:tableView]; cell.status = self.statues[indexPath.row]; // 将数据传进cell [cell layoutIfNeeded]; return cell.height;&#125; ####非等高cell123456789101112131415161718192021- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; MuziCell *cell = [MuziCell cellWithTableView:tableView]; cell.status = self.statues[indexPath.row]; // 将数据传进cell [cell layoutIfNeeded]; self.heights[@(indexPath.row)] = @(cell.height); // 字典里面是对象 return cell;&#125;// 返回估计高度,非常重要，调节cellforRow和heightForRow的调用方法- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath)indexPath&#123; return 200;&#125;- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath)indexPath&#123; // 将上面的高度存起来，拿到这里使用 return [self.heights[@(indexPath.row)] doubleValue];&#125; ###设置UITableView分割线距左边的间距1234567-(void)viewDidLoad&#123;[super viewDidLoad];[self.tableView setSeparatorInset:UIEdgeInsetsZero];[self.tableView setLayoutMargins:UIEdgeInsetsZero];&#125; ####在cell将要显示出来的方法中执行下面的代码12345-(void)tableView:(UITableView )tableView willDisplayCell:(UITableViewCell )cell forRowAtIndexPath:(NSIndexPath *)indexPath&#123; [cell setSeparatorInset:UIEdgeInsetsZero]; [cell setLayoutMargins:UIEdgeInsetsZero];&#125; ###iOS隐藏导航栏正确做法 #####以往我们隐藏导航栏都是这样做：12345678- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; [self.navigationController setNavigationBarHidden:YES animated:YES];&#125;-(void)viewWillDisappear:(BOOL)animated&#123; [super viewWillDisappear:animated]; [self.navigationController setNavigationBarHidden:NO animated:YES];&#125; #####但是往往这样 会遇到一些奇怪的 bug ，想来想去 我想到这样做可能要更好一点:123456789- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; [self.navigationController.view sendSubviewToBack:self.navigationController.navigationBar];&#125;-(void)viewWillDisappear:(BOOL)animated&#123; [super viewWillDisappear:animated]; [self.navigationController.view bringSubviewToFront:self.navigationController.navigationBar];&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-08-29T06:34:53.000Z","updated":"2017-08-30T02:21:02.000Z","comments":true,"path":"2017/08/29/hello-world/","link":"","permalink":"http://yoursite.com/2017/08/29/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}